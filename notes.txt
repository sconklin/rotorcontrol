This is being designed to operate an az/el rotator built from a pan/tilt camera mount.

Each axis is driven by a 120VAC motor. Each motor is directional and has three-leads. One lead is connected to neutral, and each other lead corresponds to a direction. 

There is no brake.

Protocol will be EASYCOMM II

The remainder of this document was written before major design changes and is very innacurate.

===================================================================
think about a feature set:
  manual control from front panel
  serial port control
  soft limits?
  status display
  USB/Serial isolation?
===================================================================
Front panel controls/indicators:

LCD panel - target heading, current heading
LEDs - Motor indicator, Brake indicator, power indicator, serial indicator
Position knob
"go" button
"menu" button

Circuit:
  Arduino (mega?)
  analog input from position circuit
  Three relay outputs (Brake/power, CCW, CW)
  Serial port
  LCD interface
  4 LED outputs (possibly color)
  Two rotary encoder inputs with push buttons

I2C expansion as needed
http://www.neufeld.newton.ks.us/electronics/?p=241

LCD Pins (6 outputs required):
D4
D5
D6
D7
ENABLE
RS
R/W - to GND
Contrast - to bias pot

Arduino pins:

Digital:
 0: RX
 1: TX
 2:
 3: (pwm)
 4:
 5: (pwm)
 6: (pwm)
 7: LCD_RS
 8: LCD_EN
 9: (pwm) LCD_D4
10: (pwm) LCD_D5
11: (pwm) LCD_D6
12: LCD_D7
13:

Analog:
 0: Rotator position feedback
 1: 
 2:
 3:
 4: I2C SDA
 5: I2C SCL

I2C Expansion:
 Port 0 (out):
 0: Brake Solenoid and AC
 1: Motor CCW
 2: Motor CW
 3:
 4:
 5:
 6:
 7:
 Port 1 (input):
 8: Right encoder button
 9: Left encoder button
10: Right encoder A phase
11: Right encoder B phase
12: Left encoder A
13: Left encoder B
14:
15:


LCD layout - 2x20

XXXXXXXXXXXXXXXXXXXX
 Target: nnn  LOCK
Current: nnn  L B R
XXXXXXXXXXXXXXXXXXXX


Pseudocode

__timer variables are decremented every millisecond (more or less) until they reach zero, then they stay zero. The decrementing is done in an ISR.

Setup:

Loop:

config params in EEprom:
coast time in mS
analog read delay in mS
number of analog samples to average
int ccwlimit
int cwlimit

button states for two front panel buttons
int brake_timer
int sample_time
int num_samples
int move_pending .. zero or the AP number to move to
int current_position
int front_panel // position of front panel control
int destination // where we are headed on this move
int AP1 // where the AM1 command will send us
int AP2
etc

// States: MOVING, COASTING, BRAKED

  // read the current position
  if (sample_time == 0) {
    read the current values and save it to the sample circular buffers
    average the samples
    save current_position
    save front_panel
    set sample_time = configuration value
  }

if Serial input is present, parse it:
   AIn; - reads heading, returns three digits leading zeroes "xxx;"
   (for any state)
   read the current heading and return it

   STn; - stops all rotation
   switch(state) {
   case MOVING:
   	turn off motor
	set state to COASTING
	set coasting timer
	move_pending = FALSE
	continue
   case COASTING:
   case BRAKED:
   	do nothing
	continue
   default:
	ERROR
}

   APnxxx(.y); - Sets rotation degrees to xxx degrees and optionslly y tenths for next AMn; command
   (for any state)
   save to the appropriate APn variable
   
   AMn; send rotor to last APn setting
   switch (state):
   case MOVING:
       if moving in the right direction
           set destination = APn
       if moving in the wrong direction
           turn off motor
           set state to COASTING
           set coasting timer
	   move_pending = AP number
           continue
   case COASTING:
       // keep coasting
       move_pending = AP number
       continue
   case BRAKED:
       set destination = APn
       set state to MOVING
       turn on correct direction
       continue

   // now for normal operation cases - no input received.
   case MOVING:
   	have we hit a limit for the direction we are moving?
        if yes, deal with it

      are we there yet? (maybe have a coasting algorithm)
      if no, continue. (does south need special case)
      if yes, then:
        turn off motor
        set state to COASTING
        set coasting timer
        break;

   case COASTING:
    	if (coasting_timer == 0) {
	    // done
            if (move_pending) {
	       set destination = APn
               set state to MOVING
               turn on correct direction
            } else {
              set state = BRAKED
              turn on BRAKE (turn off power)
            }
        }
	break;

   case BRAKED:
        if (move_pending) {
	   set destination = APn
	   set state to MOVING
	   turn off brake (turn on power)
	   turn on correct direction
	}
	break;

    

  // update the display
  write current position
  write target position
  write front panel position
  write motor and brake state


  // read the front panel buttons
  Left button labeled "Menu", right labeled "Enter"

============= User Interface =============

  Normal Display
  XXXXXXXXXXXXXXXXXXXX
   Target: nnn  LOCK
  Current: nnn  L B R
  XXXXXXXXXXXXXXXXXXXX

* When Braked only:
  Left button enters Config Menu (No movement from serial commands while in Menu)
  While in config menu:
    Left button exits menu and re-enables serial movement
    Left rotation selects setting
    Right rotation changes setting value
    Right button enters new setting value

  Config Menu Display
  XXXXXXXXXXXXXXXXXXXX
   Name: Setting name
  Value: Setting value
  XXXXXXXXXXXXXXXXXXXX


* When braked or when turning:
  Right button stops rotation if moving, starts brake timer
  Display Changes from "Target" to "Goto"
  No serial movement commands are recognized

  Goto Display
  XXXXXXXXXXXXXXXXXXXX
     Goto: nnn  LOCK
  Current: nnn  L B R
  XXXXXXXXXXXXXXXXXXXX

  Left button exits back to normal mode and re-enables serial movement
  Right rotation changes 'goto' heading
  Right button enters target heading, starts movement, exits to normal mode

===========================================================================

Configuration Menu - types of settings:

Integers - Max, Min
List - Integer plus a list of names

Each setting in the config menu has:
  Type
  min value
  max value
  ptr to handler for new setting
  ptr to list of names (for list type)
